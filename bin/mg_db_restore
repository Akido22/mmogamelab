#!/usr/bin/python2.6
# -*- coding: utf-8 -*-

from mg import *
from concurrence import dispatch, quit
import os
import logging
import sys
import json
import re
import time
import dircache

token_ring = 2 ** 127
parts = 256
token_part = token_ring / parts

def restore(db, app, now):
    for family in ["Objects", "Indexes"]:
        try:
            f = open("%s-%s.json" % (family, app), "r")
        except IOError:
            continue
        for line in f:
            row = json.loads(line.strip())
            for key, val in row.iteritems():
                if type(key) is unicode:
                    key = key.encode("utf-8")
                mutations = []
                for col_name, col_value in val.iteritems():
                    if type(col_name) is unicode:
                        col_name = col_name.encode("utf-8")
                    if type(col_value) is unicode:
                        col_value = col_value.encode("utf-8")
                    mutations.append(Mutation(ColumnOrSuperColumn(Column(name=col_name, value=col_value, timestamp=now))))
                mutations = {"%s-%s" % (app, key): {family: mutations}}
                print "%s/%s-%s" % (family, app, key)
                db.batch_mutate(mutations, ConsistencyLevel.ONE)

def main():
    try:
        if len(sys.argv) != 2:
            print "usage: mg_db_restore <app> or mg_db_restore all"
            os._exit(1)
        inst = Instance("db_restore")
        inst.download_config()
        mc = Memcached(inst.mcpool)
        db = inst.dbpool.dbget("main", mc)
        created = set()
        now = time.time() * 1000
        app = sys.argv[1]
        if app == "all":
            restored = set()
            for ent in dircache.listdir("."):
                m = re.match(r'^(?:Objects|Indexes)-(\S+).json', ent)
                if m:
                    app = m.group(1)
                    if app not in restored:
                        restore(db, app, now)
                        restored.add(app)
        else:
            restore(db, app, now)
        sys.stdout.flush()
        os._exit(0)
    except RuntimeError as e:
        logging.error(e)
        os._exit(1)
    except Exception as e:
        logging.exception(e)
        os._exit(1)

dispatch(main)

