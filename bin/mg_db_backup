#!/usr/bin/python2.6
# -*- coding: utf-8 -*-

from mg import *
from concurrence import dispatch, quit
import os
import logging
import sys
import json
import re

token_ring = 2 ** 127
parts = 256
token_part = token_ring / parts

def main():
    try:
        if len(sys.argv) != 2:
            sys.stderr.write("usage: mg_db_backup <db_host>\n")
            os._exit(1)
        # logging
        modlogger = logging.getLogger("")
        modlogger.setLevel(logging.DEBUG)
        stderr_channel = logging.StreamHandler()
        stderr_channel.setLevel(logging.DEBUG)
        modlogger.addHandler(stderr_channel)
        # database
        db = CassandraConnection((sys.argv[1], 9160))
        db.connect()
        for ksdef in db.cass.describe_keyspaces():
            keyspace = ksdef.name
            if keyspace == "system" or keyspace == "ringtest":
                continue
            db.cass.set_keyspace(keyspace)
            os.mkdir(keyspace)
            print keyspace
            for cf in ksdef.cf_defs:
                family = cf.name
                print " - %s" % family
                filename = "%s/%s.json" % (keyspace, family)
                f = open(filename, "w")
                for part in xrange(0, parts):
                    start_token = '%d' % (part * token_part)
                    end_token = '%d' % (((part + 1) * token_part) % token_ring)
                    lst = db.cass.get_range_slices(ColumnParent(family), SlicePredicate(slice_range=SliceRange("", "", False, 1000000000)), KeyRange(count=10000000, start_token=start_token, end_token=end_token), ConsistencyLevel.ONE)
                    for ent in lst:
                        if len(ent.columns):
                            columns = {}
                            for col in ent.columns:
                                columns[col.column.name] = col.column.value
                            row = {ent.key: columns}
                            f.write(json.dumps(row))
                            f.write("\n")
                f.close()
        sys.stdout.flush()
        os._exit(0)
    except RuntimeError as e:
        logging.error(e)
        os._exit(1)
    except Exception as e:
        logging.exception(e)
        os._exit(1)

dispatch(main)

