<!-- doc.title Квесты и триггеры в конструкторе игр -->
<!-- doc.parent index -->
<!-- doc.keywords квесты, триггеры, события, действия, обработчики, онлайн-игры -->
<!-- doc.description Описание работы квестового движка в конструкторе онлайн-игр -->

<h1>Квесты и триггеры</h1>

<p>Квестовый движок позволяет администраторам онлайн-игр создавать в своих играх триггеры, описывающие на языке MMOScript реакцию системы на какие-либо события, и описывать квесты, которые персонажи могут проходить.</p>

<p>Чтобы квестовый движок подключился к вашей игре, вам необходимо включить <a href="/doc/modules">модуль</a> "Квестовый движок". После этого в административном интерфейсе появится меню "Квесты и триггеры", через который настраивается основная часть системы.</p>

<h1>Архитектура квестового движка</h1>

<p>Квестовый движок представляет собой механизм для задания реакции системы на различные события. Администратор игры описывает реакцию при помощи скриптов на языке MMOScript. Скрипт &mdash; это небольшая программа, которая вызывается при возникновении какого-либо события. Других способов выполнить скрипт не существует.</p>

<p>Событиями, которые могут привести к выполнению скриптов, являются:<ul>
	<li>регистрация в игре;</li>
	<li>вход в игру;</li>
	<li>выход из игры;</li>
	<li>нажатие на кнопку в интерфейсе игры;</li>
	<li>переход персонажа в другую локацию;</li>
	<li>активация специальной зоны на изображении локации;</li>
	<li>нажатие на кнопку в квестовом диалоге;</li>
	<li>осуществление какого-либо действия с предметом;</li>
	<li>отключение какого-либо модификатора (например, платной услуги);</li>
	<li>срабатывание таймера;</li>
	<li>ручной вызов события другим скриптом.</li>
</ul></p>

<p>Чтобы событие привело к выполнению какого-либо скрипта, администратор должен присоединить к этому событию обработчик. Обработчик события &mdash; это специальная конструкция на языке MMOScript, описывающая условия его срабатывания и действия, которые должны быть осуществлены при выполнении всех условий:</p>

<p><img src="/st/tutorial/events1.png" alt="" /></p>

<p>Приведённой выше схемы достаточно для того, чтобы реализовать обычные триггеры. Однако для того, чтобы сделать полноценную систему нелинейных квестов, она крайне неудобна. Дело в том, что по мере прохождения персонажем квеста реакция системы на его действия должна быть различной. К примеру, в начале квеста при попытке поговорить с NPC игроку должен показываться один диалог, а при дальнейшем прохождении - другие. В зависимости от состояния квеста могут переключаться и другие реакции. Чтобы при возникновении каждого из событий администратору вручную не приходилось прописывать множество проверок, в которых можно легко запутаться, в квестовом движке явно введены понятия: "квест" и "состояние квеста".</p>

<p>В обычном понимании, <strong>квест</strong> &mdash; это сюжетная единица заданий для персонажа. Персонаж получает задание (обычно от какого-то NPC), выполняет его, затем либо получает следующее задание, либо награду. Квесты могут быть нелинейными, то есть, в зависимости от действий персонажа, изменять свой ход. В конструкторе игр понятие "квест" используется условно. При помощи квестового движка можно описывать реакцию системы на события, относящиеся не только к квестам. Квестом называется просто группа обработчиков, которые администратору по смыслу удобно хранить вместе. Хотя при реализации квестов в обычном понимании этого слова квест конструктора и будет соответствовать игровому квесту.</p>

<a name="state"></a>
<p>У квеста есть параметр "<strong>p_state</strong>" (состояние), определяющий состояние данного персонажа в данном квесте. Это обычная строка. Когда администратор только что создал квест, все персонажи получают в этом квесте состояние "init" (начальное). Когда персонаж "возьмёт квест" (например, согласится выполнить задание NPC), при помощи скрипта состояние данного персонажа в данном квесте переводится в какое-либо другое, например "go_somewhere" (сходи куда-нибудь). С того момента, как состояние квеста стало любым, отличным от "init", квест считается взятым. Когда квест будет либо пройден до конца, либо прерван, состояние вновь сменится на "init".</p>

<p>Создавая квест, администратор описывает множество обработчиков, привязывая каждый из них к определённому состоянию определённого квеста. Вне состояний и вне квестов скрипты писать невозможно. Рассмотрим, например, квест, где NPC A предлагает персонажу взять предмет I и отнести его к NPC B. У квеста будут два состояния:<ul>
	<li>init &mdash; квест не взят. В этом состоянии при клике на NPC A покажется диалог, предлагающий задание;</li>
	<li>go_somewhere &mdash; квест взят, персонажу выдан предмет I, и надо его нести NPC B. В этом состоянии при клике на NPC B покажется диалог, в котором B благодарит персонажа и выдаёт ему награду.</li>
</ul></p>

<p><img src="/st/tutorial/events2.png" alt="" /></p>

<p>При возникновении события "клик на A", квестовый движок:<ul>
	<li>загружает все квесты, которые имеют обработчик события "клик на A" (в данном случае, это квест "courier");</li>
	<li>смотрит, в каком состоянии в данном квесте находится данный персонаж (изначально в состоянии "init");</li>
	<li>если в этом состоянии обработчик "клик на A" существует (а он существует), то выполняются описанные им действия (показывается диалог "возьми задание").</li>
</ul></p>

<p>В диалоге "возьми задание" администратор пишет текст, который увидит игрок. Там сказано: "возьми вот этот предмет I и отнеси его B". И доступны две кнопки - "Я согласен" и "Я не согласен". При нажатии на "Я не согласен" диалог просто закрывается, т.к. обработчиков для этого события нигде не описано. Когда нажимается "Я согласен", то персонажу выдаётся предмет I, а состояние квеста изменяется на "go_somewhere".</p>

<p>С того момента, как квест перешёл в состояние "go_somewhere", автоматически отключаются все обработчики из состояния "init" и подключаются обработчики из "go_somewhere". То есть, если теперь попытаться поговорить с NPC A, то игрок увидит другой диалог: "Что ты ко мне пришёл снова? Я же тебе дал задание. Вот иди и выполняй".</p>

<p>Когда персонаж дойдёт до NPC B и заговорит с ним, то предмет I будет автоматически изъят, а на экране у игрока появится диалог: "Спасибо, я так рад этой посылке. Возьми награду". В диалоге единственная кнопка: "Взять награду", по которой выдаётся какой-то предмет, деньги или опыт, и квест завершается.</p>

<p>Завершение квеста выполняет обратный перевод квеста в состояние "init". То есть, если теперь игрок кликнет на A, то квест будет предложен снова.</p>

<p>Когда квест взят (состояние не "init"), то в кнопке игрового интерфейса "Квесты" появится <strong>описание текущего состояния</strong> взятого квеста. Как правило, администратор пишет туда подсказки по выполнению задания. Например, в состоянии "go_somewhere" имеет смысл написать что-то вроде: "Отнеси NPC B предмет I". Опционально, туда же можно поместить кнопку "Отказаться от квеста", которая будет прерывать квест, переводя его в состояние "init".</p>

<p>При любом завершении квеста (успешном и неудачном) квест переводится в состояние "init". Отличие успешного заключается в том, что в специальной базе данных квест помечается как завершённый, что приводит к его отображению в списке пройдённых персонажем квестов. Кроме того, этот признак можно проверять для того, чтобы повторно не выдавать уже пройденный квест.</p>

<h1>Редактор квестов и состояний</h1>

<p>Список существующих квестов доступен через пункт меню "Квесты и триггеры / Редактор квестов": <img class="doc-screenshot" src="/st/tutorial/quests-1.png" alt="" /></p>
<p>Параметры квеста настраиваются через специальную форму: <img class="doc-screenshot" src="/st/tutorial/quests-2.png" alt="" /></p>
<ul>
	<li>Идентификатор квеста &mdash; это код, через который можно обратиться к этому квесту через скриптовый движок. Например, чтобы обратиться к квесту, приведённому на скриншоте, необходимо написать: <pre class="doc-code-sample">char.q_inout</pre></li>
	<li>название квеста &mdash; будет отображатся в интерфейсе игрока "Квесты", когда квест будет взят;</li>
	<li>квест включен &mdash; снятие этой галочки позволяет отключить квест, чтобы ни один его обработчик не выполнялся, и квест исчез из списков текущих и завершённых квестов;</li>
	<li>квест доступен персонажу &mdash; это скриптовое условие, позволяющее определить, должны ли обработчики этого квеста срабатывать для данного персонажа, и должен ли квест показываться в списке текущих квестов. К примеру, чтобы квест был доступен только девушкам, напишите:<pre class="doc-code-sample">char.sex == 1</pre>
	<li>выводить отладочную информацию в отладочный канал &mdash; это удобное средство для отладки квеста. Чтобы увидеть отладочные сообщения, вам необходимо включить отладочный канал (через меню "Социалка / Чат / Конфигурация чата") и добавить себя в список пользователей, кому виден чат (меню "Социалка / Чат / Отладочный канал чата").</li>
</ul>

<p>Если нажать на ссылку "открыть" рядом с квестом, то откроется список состояний квеста: <img class="doc-screenshot" src="/st/tutorial/quests-3.png" alt="" /></p>

<p>Через этот интерфейс вы можете перейти в редактор состояния, где, собственно, и находится самая главная часть квестового движка &mdash; скрипты: <img class="doc-screenshot" src="/st/tutorial/quests-4.png" alt="" /></p>

<ul>
	<li>Идентификатор состояния &mdash; это строка, соответствующая параметру квеста "p_state" (см. <a href="#state">выше</a>);</li>
	<li>порядок сортировки &mdash; состояния сортируются в порядке возрастания этого параметра;</li>
	<li>скрипт квеста &mdash; программа на языке MMOScript, представляющая собой простое перечисление обработчиков событий один за другим. На приведённом скриншоте приведена простая программа, которая при регистрации нового персонажа выдаёт ему 100 золота с примечанием "Стартовые деньги" и открывает диалог с текстом "Приветствуем вас в нашей игре!"</li>
</ul>

<h1>Синтаксис языка MMOScript</h1>

<p>Язык не чувствителен к пробелам и отступам. Можно писать команды в одну строчку, можно с новой строки, можно с любым количеством отступов. Однако после сохранения программы информация об оформлении кода теряется, и при следующей загрузке программы она будет выглядеть стандартным образом.</p>

<p>В поле "Скрипт квеста" вводятся обработчики событий один за другим. Синтаксис всех обработчиков одинаков:</p>
<pre class="doc-code-sample">
<strong>событие</strong> {
  <strong>действие</strong>
  <strong>действие</strong>
  ...
}
</pre>
<p>Событие описывает ситуацию, когда обработчик должен сработать. А действия &mdash; это собственно реакции системы, которые вы хотите получить. Например, если вы хотите при каждом входе персонажа в игру выдавать ему предмет "2398472934", то событием будет "online", а действием &mdash; 'give item="2398472934"':</p>
<pre class="doc-code-sample">
online {
  give item="2398472934"
}
</pre>

<h1>Виды событий</h1>

<p>В этом разделе приведены различные события, которые можно подставлять вместо слова "событие" в описании обработчика.</p>

<h2>Реакция на событие, вызванное квестовым движком</h2>
<pre class="doc-code-sample">
event "<strong>идентификатор</strong>" {
  ...
}
</pre>
<p>Если в каком-то другом месте квеста написать:</p>
<pre class="doc-code-sample">
call event="<strong>идентификатор</strong>"
</pre>
<p>то событие с указанным идентификатором вызовется и будет перехвачено указанным выше обработчиком.</p>

<h2>Переход в другую локацию</h2>
<pre class="doc-code-sample">
teleported from="<strong>излокации</strong>" to="<strong>влокацию</strong>" {
  ...
}
</pre>
<p>Этот обработчик сработает, если персонаж перейдёт из первой указанной локации во вторую. Параметры from и to необязательные. Можно указать только один из них, либо вообще ни одного. В последнем случае обработчик будет срабатывать при каждом переходе между локациями. Пример:</p>
<pre class="doc-code-sample">
teleported {
  message "Вы перешли в другую локацию"
}
</pre>

<h2>Истечение срока действия модификатора</h2>
<pre class="doc-code-sample">
expired "<strong>идентификатор</strong>" {
  ...
}
</pre>
<p>Когда у персонажа заканчивается действие какого-либо модификатора (например, платной услуги), то это событие можно обработать. Например, если заканчивается ускоренное перемещение по локациям, пишем сообщение в чат:</p>
<pre class="doc-code-sample">
expired "fastmove" {
  chat text="Подписка кончилась"
}
</pre>

<h2>Срабатывание таймера</h2>
<pre class="doc-code-sample">
timeout "<strong>идентификатор</strong>" {
  ...
}
</pre>
<p>Чтобы завести таймер на какой-либо интервал времени, воспользуйтесь командой:</p>
<pre class="doc-code-sample">
timer id="<strong>идентификатор</strong>" timeout="<strong>время</strong>"
</pre>
<p>При его срабатывании будет вызван указанный выше обработчик.</p>

<h2>Использование предмета</h2>
<pre class="doc-code-sample">
itemused "<strong>кодкнопки</strong>" {
  ...
}
</pre>
<p>Если к игре подключена <a href="/doc/inventory">система инвентаря</a> то через меню "Квесты и триггеры / Действия для предметов" можно создавать различные дополнительные кнопки на предметах, а затем использовать их в квесте: <img class="doc-screenshot" src="/st/tutorial/quests-5.png" alt="" /></p>
<p>Для каждой кнопки можно прописать скриптовое условие, при котором она будет видна. В этом условии можно использовать глобальные переменные "item" и "char", которые представляют предмет и персонажа соответственно. При нажатии на такую кнопку сработает обработчик itemused с соответствующим кодом.</p>
<p>Например, чтобы уничтожить предмет при нажатии на нём кнопки "взорвать", напишите обработчик:</p>
<pre class="doc-code-sample">
itemused "explode" {
  take dna=item.dna quantity=1
  message "{char.name} [char.sex:взорвал,взорвала] {item.name_a}"
}</pre>
<p>В обработчик itemused передаются глобальные переменные "item" (тип <a href="/doc/inventory#object">Item</a>) и "char", которые представляют предмет и персонажа соответственно.</p>

<h2>Нажатие на кнопку в квестлоге</h2>
<pre class="doc-code-sample">
button id="<strong>идентификатор</strong>" text="<strong>текст</strong>" {
  ...
}
</pre>
<p>При наличии такого обработчика в квестлоге рядом с квестом появится кнопка с текстом "текст", при нажатии на которую будет вызван приведённый выше обработчик. Кнопок может быть любое количество.</p>

<h2>Регистрация персонажа</h2>
<pre class="doc-code-sample">
registered {
  ...
}
</pre>
<p>Это событие вызывается всего один раз &mdash; при создании персонажа. Можно выдать персонажу стартовые деньги и предметы, открыть стартовый диалог и т.п.</p>

<h2>Вход в игру</h2>
<pre class="doc-code-sample">
online {
  ...
}
</pre>
<p>Вызывается при любом входе в игру.</p>

<h2>Выход из игры</h2>
<pre class="doc-code-sample">
offline {
  ...
}
</pre>
<p>Вызывается при любом выходе из игры (по пропаданию связи, по кнопке выхода и т.д.)</p>

<h2>Нажатие на кнопку в интерфейсе пользователя</h2>
<pre class="doc-code-sample">
clicked "<strong>идентификатор</strong>" {
  ...
}
</pre>
<p>Когда в браузере вызывается команда "Game.qevent('идентификатор')" или изнутри игрового фрейма "parent.Game.qevent('идентификатор')", на сервер доставляется сообщение о вызове события с указанным идентификатором, и квестовый движок исполняет соответствующие обработчики clicked.</p>
<p>Этот механизм применяется для привязки обработчиков к кнопкам игрового интерфейса, к пунктам выпадающих меню и к активным зонам на локациях. Чтобы прописать событие для кнопки или пункта меню, зайдите в раздел "Интерфейс игры / Редактор кнопок", создайте кнопки, которые вам необходимы, пропишите им действие "Вызвать квестовое событие clicked" и укажите идентификатор события: <img class="doc-screenshot" src="/st/tutorial/quests-6.png" alt="" /></p>

<h2>Выбор класса персонажа</h2>
<pre class="doc-code-sample">
class selected {
  ...
}
</pre>
<p>Вызывется, когда игрок выбирает класс персонажа через специальный игровой интерфейс. В этом обработчике доступны глобальные переменные:</p>
<ul>
	<li>cls &mdash; название выбранного игроком параметра, например, "race";</li>
	<li>oldval &mdash; старое значение параметра (0);</li>
	<li>newval &mdash; новое значение параметра (идентификатор выбранного варианта).</li>
</ul>

<h2>Покупка товара в магазине</h2>
<pre class="doc-code-sample">
shop bought {
  ...
}
</pre>
<p>Вызывается, когда персонаж покупает товар в магазине.</p>

<h2>Продажа товара в магазин</h2>
<pre class="doc-code-sample">
shop sold {
  ...
}
</pre>
<p>Вызывается, когда персонаж продал товар в магазин.</p>

<h2>Надевание предмета</h2>
<pre class="doc-code-sample">
equip wear {
  ...
}
</pre>
<p>Вызывается, когда персонаж надел предмет в слот. Обработчику доступны глобальные переменные item (предмет, который был надет) и slot (идентификатор слота).</p>

<h2>Снятие предмета</h2>
<pre class="doc-code-sample">
equip unwear {
  ...
}
</pre>
<p>Вызывается, когда персонаж снял предмет из слота. Обработчику доступны глобальные переменные item (предмет, который был надет) и slot (идентификатор слота).</p>

<h2>Спадание предмета</h2>
<pre class="doc-code-sample">
equip drop {
  ...
}
</pre>
<p>Вызывается, когда с персонажа свалился предмет экипировки в результате невыполнения требований. Обработчику доступны глобальные переменные item (предмет, который был надет) и slot (идентификатор слота).</p>

<h1>Действия при выполнении обработчиков</h1>

<p>В этом разделе приведён перечень действий, которые можно выполнить при срабатывании обработчика. Все действия в скрипте выполняются последовательно сверху вниз. Есть действия, которые прерывают ход выполнения скрипта в случае неудачи. Например, required.</p>

<p>В этом разделе используются обозначения:</p>
<ul>
	<li><strong>выражение</strong> &mdash; выражение <a href="/doc/script">скриптового движка</a>;</li>
	<li><strong>текстовое выражение</strong> &mdash; текстовая строка, которая может <a href="/doc/script#text">формироваться</a> скриптовым движком.</li>
</ul>

<h2>Показ сообщения игроку</h2>
<pre class="doc-code-sample">
message "<strong>текстовое выражение</strong>"
</pre>
<p>В игровом интерфейсе всплывёт сообщение с указанным текстом.</p>

<h2>Показ сообщения об ошибке</h2>
<pre class="doc-code-sample">
error "<strong>текстовое выражение</strong>"
</pre>
<p>В игровом интерфейсе всплывёт сообщение об ошибке с указанным текстом. Похоже на message, только обычно красным цветом.</p>

<h2>Предусловие</h2>
<pre class="doc-code-sample">
require <strong>выражение</strong>
</pre>
<p>Будет вычислено указанное выражение, и, если оно ложно, то выполнение обработчика будет прервано.</p>

<a name="call"></a>
<h2>Вызов события</h2>
<pre class="doc-code-sample">
call event="<strong>событие</strong>"
</pre>
и
<pre class="doc-code-sample">
call quest="<strong>квест</strong>" event="<strong>событие</strong>"
</pre>
<p>Первая форма вызывает событие с указанным идентификатором, которое может быть перехвачено обработчиком "event". Вторая форма позволяет вызвать событие другого квеста. Это может быть полезно, когда, например, выполнение одного квеста должно автоматически переключить состояние в другом квесте. К примеру, если персонаж выполнит квест A, то надо прерывать и квест B. Тогда в квесте A вы можете написать:</p>
<pre class="doc-code-sample">
call quest="B" event="terminate"
</pre>
<p>А в квесте B обработчик для terminate:</p>
<pre class="doc-code-sample">
event "terminate" {
  error "Квест B прерван"
  fail
}
</pre>
<p>У команды call есть необязательный аргумент char=<strong>выражение</strong>. Если с его помощью указать идентификатор персонажа, то событие будет вызвано в контексте именно этого персонажа. Например, если вы хотите, чтобы при выполнении какого-либо действия администратор 29057012395238768 получал уведомление об этом в чат, то вы можете написать:</p>
<pre class="doc-code-sample">
call event="something_happened" char="29057012395238768"
</pre>
<p>А в состоянии init квеста (чтобы администратор, не проходящий квест, его увидел) напишите:</p>
<pre class="doc-code-sample">
event "something_happened" {
  message "Что-то произошло"
}
</pre>

<h2>Выдача денег</h2>
<pre class="doc-code-sample">
give amount=<strong>сумма</strong> currency="<strong>валюта</strong>"
</pre>
<p>Персонажу будет выдана указанная сумма денег. Сумма и валюта &mdash; это скриптовые выражения, т.е. их можно вычислять на лету. Если значение более миллиарда, то будет выдан миллиард.</p>
<p>Чтобы вручную задать примечание к переводу денег, можно указать дополнительный параметр comment="<strong>комментарий</strong>".</p>

<h2>Изъятие денег</h2>
<pre class="doc-code-sample">
take amount=<strong>сумма</strong> currency="<strong>валюта</strong>" onfail="<strong>событие</strong>"
</pre>
<p>У персонажа будет изъята указанная сумма денег. Сумма и валюта &mdash; это скриптовые выражения, т.е. их можно вычислять на лету.</p>
<p>При неудачной попытке списания денег выполнение обработчика будет прервано. Параметр onfail не является обязательным. Если его задать, то при неудачном списании будет вызвано указанное событие, которое можно обработать при помощи обработчика "event".</p>
<p>Чтобы вручную задать примечание к переводу денег, можно указать дополнительный параметр comment="<strong>комментарий</strong>".</p>
<p>Например, если по условию квеста персонаж должен отдать 1000 золота", чтобы пройти на следующий этап, то вы можете задать такой скрипт:</p>
<pre class="doc-code-sample">
button id="done" text="Сдать квест" {
  take amount=1000 currency="GOLD" onfail="nomoney"
  message "Поздравляем! Вы прошли квест!"
  finish
}
event "nomoney" {
  error "Недостаточно средств в данной валюте"
}
</pre>

<h2>Выдача предметов</h2>
<pre class="doc-code-sample">
give item="<strong>тип</strong>" quantity=<strong>количество</strong>
</pre>
<p>Персонажу будет выдана указанное количество предметов. Если количество не указано, то будет выдан 1 предмет. Количество &mdash; это скриптовое выражение. Если значение более миллиарда, то будет выдан миллиард.</p>
<p>Выдаваемые предметы могут быть <a href="/doc/inventory#instances">модифицированы</a>. Чтобы выдать модифицированный предмет, перечислите все изменённые характеристики в формате параметр=значение. Например:</p>
<pre class="doc-code-sample">
give item="bafb8258ff464dd6a02a53168488526d" p_weight=1.25 p_volume=3
</pre>

<a name="takeitems"></a>
<h2>Изъятие предметов по типу</h2>
<pre class="doc-code-sample">
take type="<strong>тип</strong>" quantity=<strong>количество</strong> onfail="<strong>событие</strong>"
take type="<strong>тип</strong>" fractions=<strong>количество</strong> onfail="<strong>событие</strong>"
</pre>
<p>Первая форма (с quantity) отвечает за изъятие у персонажа указанного количества предметов данного типа (независимо от того, модифицированы они или нет). Количество &mdash; это скриптовое выражение. Если количество не указано, то будут изъяты все предметы этого типа.</p>
<p>Вторая форма (с fractions) отвечает за изъятие у персонажа указанного количества частей предмета. Эта форма записи уместна, когда предметы данного типа <a href="/doc/inventory#fractions">делятся на части</a>. Будет изъято количество частей, указанное в параметре fractions.</p>
<p>Предметы, имеющиеся в инвентаре, могут иметь различные <a href="/doc/inventory#instances">модификации</a>. Система будет стараться сначала изымать предметы с минимальным сроком годности, затем с более отдалённым и в конце предметы без срока годности. При равных сроках годности сначала части будут списываться с тех предметов, у которых количество оставшихся частей меньше.</p>
<p>При неудачной попытке изъятия предметов выполнение обработчика будет прервано. Параметр onfail не является обязательным. Если его задать, то при неудачном изъятии будет вызвано указанное событие, которое можно обработать при помощи обработчика "event". Если количество quantity не задано, то списание всегда считается удачным.</p>

<h2>Изъятие предметов по точному ДНК</h2>
<pre class="doc-code-sample">
take dna="<strong>ДНК</strong>" quantity=<strong>количество</strong> onfail="<strong>событие</strong>"
</pre>
<p>У персонажа будет изъято указанное количество предметов с данным <a href="/doc/inventory#dna">ДНК</a>. Количество &mdash; это скриптовое выражение. Если количество не указано, то будут изъяты все предметы с данным ДНК.</p>
<p>При неудачной попытке изъятия предметов выполнение обработчика будет прервано. Параметр onfail не является обязательным. Если его задать, то при неудачном изъятии будет вызвано указанное событие, которое можно обработать при помощи обработчика "event". Если количество quantity не задано, то списание всегда считается удачным.</p>

<h2>Условный оператор</h2>
<pre class="doc-code-sample">
if <strong>условие</strong> {
  ...
}
</pre>
<p>Условие &mdash; это скриптовое выражение. Если оно истинно, то блок "..." выполняется. Если ложно, то пропускается.</p>
<pre class="doc-code-sample">
if <strong>условие</strong> {
  ...
} else {
  ...
}
</pre>
<p>В этой форме оператора если условие истинно, то выполняется первый блок. Если ложно, то второй. Например, если вы хотите сделать проверку при входе в локацию, есть ли у персонажа в инвентаре ключ (предмет 92349283742), и если есть, то открыть ему диалог, а если нет, то показать сообщение, то можно написать так:</p>
<pre class="doc-code-sample">
if char.inv.cnt_92349283742 {
  dialog {
    ...
  }
} else {
  error "У вас в инвентаре нет ключа"
}
</pre>

<h2>Изменение параметра</h2>
<pre class="doc-code-sample">
set <strong>объект</strong>.<strong>параметр</strong> = <strong>выражение</strong>
</pre>
<p>Эта команда позволяет изменять параметры у объектов, которые это позволяют. К примеру, чтобы выдать персонажу 10 единиц опыта, вы можете написать:</p>
<pre class="doc-code-sample">
set char.p_xp = char.p_xp + 10
</pre>
<p>Аналогичным образом можно изменять состояние текущего квеста:</p>
<pre class="doc-code-sample">
set quest.p_state = "go_somewhere"
</pre>

<h2>Успешное завершение квеста</h2>
<pre class="doc-code-sample">
finish
</pre>
<p>Переводит квест в состояние "init", уничтожает объект с текущим состоянием квеста и помечает квест как пройденный.</p>
<p>Позже вы можете делать проверку, пройден был квест или нет, при помощи атрибута квеста "finished". Например, если вы хотите, чтобы какой-то квест выдавался только тем персонажам, кто уже прошёл квест "courier", то напишите в условии взятия нового квеста:</p>
<pre class="doc-code-sample">
require char.q_courier.finished
</pre>

<h2>Неудачное завершение квеста</h2>
<pre class="doc-code-sample">
fail
</pre>
<p>Переводит квест в состояние "init" и уничтожает объект с текущим состоянием квеста.</p>

<h2>Установка блокировки на квест</h2>
<pre class="doc-code-sample">
lock timeout=<strong>выражение</strong>
</pre>
<p>Устанавливает блокировку квеста на указанное количество секунд. Если параметр timeout не указан, то блокировка устанавливается пожизненно. Позже можно проверить наличие блокировки при помощи атрибутов квеста "locked" и "notlocked". К примеру, если вы хотите, чтобы после успешного прохождения квеста его нельзя было брать ещё неделю, то при завершении квеста напишите:</p>
<pre class="doc-code-sample">
lock timeout=604800
</pre>
А в условии взятия квеста напишите:
<pre class="doc-code-sample">
require quest.notlocked
</pre>
<p>Максимально допустимый интервал времени &mdash; 100 млн секунд (порядка 3 лет).</p>

<h2>Установка таймера</h2>
<pre class="doc-code-sample">
timer id="<strong>идентификатор</strong>" timeout=<strong>выражение</strong>
</pre>
<p>Запускается таймер на указанное количество секунд. Когда время истечёт, будут выполнены обработчики "timeout" с указанным идентификатором.</p>
<p>Если таймер с одним и тем же идентификатором запустить несколько раз, то, пока все интервалы не истекут, событие "timeout" вызвано не будет. А в конце оно будет вызвано ровно один раз.</p>
<p>Максимально допустимый интервал времени &mdash; 100 млн секунд (порядка 3 лет).</p>

<h2>Открытие диалога</h2>
<pre class="doc-code-sample">
dialog {
  title "<strong>заголовок</strong>"
  text "<strong>текст</strong>"
  template "<strong>шаблон</strong>"
  button {
    text "<strong>текст кнопки</strong>"
    event "<strong>событие кнопки</strong>"
  }
  ...
}
</pre>
<p>Указанная команда откроет диалог с заголовком title и текстом text. И title, и text являются текстовыми выражениями. Оба параметра не являются обязательными.</p>
<p>Если указан параметр template, то вместо стандартного шаблона dialog.html будет использован указанный.</p>
<p>В диалоге может быть произвольное количество кнопок, каждая из которых описывается директивой button. У кнопки есть параметр text, определяющий текст, написанный на кнопке. Параметр text необязательный и является текстовым выражением. Параметр event описывает событие, которое будет вызвано при нажатии на эту кнопку. Если event не задан, то никакие события вызваны не будут. Если кнопки в диалоге не описаны, то будет автоматически добавлена кнопка "Закрыть".</p>
<p>При нажатии на любую кнопку диалог автоматически закрывается.</p>
<p>Если открыть новый диалог, пока ещё не закрыт старый, то все открытые диалоги автоматически организуются в стек &mdash; игрок немедленно увидит новый диалог. А когда закроет его, то ему будет автоматически показан предыдущий.</p>
<p>Пока все диалоги не будут закрыты, игрок теряет возможность перемещаться по локациям, нажимать на кнопки игрового интерфейса, вызывающие какие-либо квестовые события и получать доступ к некоторым другим интерфейсам.</p>

<h2>Выбор случайной ветви исполнения</h2>
<pre class="doc-code-sample">
random {
  weight <strong>вес1</strong>:
    ...
  weight <strong>вес2</strong>:
    ...
  ...
}
</pre>
<p>Система вычисляет веса каждого из вариантов (веса являются скриптовыми выражениями) и производит случайный выбор одного из вариантов. Чем больше вес варианта, тем более вероятно, что он выпадет. Варианты с нулевым или отрицательным весом выпасть не могут.</p>
<p>Например, если вы хотите сделать кнопку "Открыть сундук", при её нажатии уничтожать сундук и выдавать случайную награду, вы можете сделать это так:</p>
<pre class="doc-code-sample">
itemused "open" {
  take dna=item.dna quantity=1
  random {
    weight 200:
      error "Вам не повезло - в сундуке ничего не было"
    weight 100:
      give amount="1" currency="GOLD"
    weight 20:
      give item="2352352345"
    weight 1:
      give item="23947293429"
      message "Вам неслыханно повезло!"
  }
}
</pre>
<p>В этом примере с вероятностью 62.3% не выпадет ничего, 31.2% выпадет 1 золотая монета, 6.2% выпадет предмет "2352352345" и 0.3% &mdash; крутой артефакт "23947293429".</p>

<h2>Телепортация персонажа</h2>
<pre class="doc-code-sample">
teleport "<strong>локация</strong>"
</pre>
<p>Телепортирует персонажа в локацию с указанным идентификатором.</p>

<a name="chat"></a>
<h2>Вывод сообщения в чат</h2>
<pre class="doc-code-sample">
chat text="<strong>текст</strong>" channel=<strong>выражение</strong> public=<strong>выражение</strong>
</pre>
<p>Выводит указанный текст в чат персонажа. Текст &mdash; это текстовое выражение. В нём разрешено использование тегов HTML, т.е. можно в чат выводить хоть картинки, хоть видеоролики с youtube. Это обязательный параметр.</p>
<p>Параметр channel определяет канал, в который следует отправить сообщение. Допустимыми значениями являются:<ul>
<li>"sys" &mdash; системный чат (без возможности фильтрации, доставляется всем);</li>
<li>"wld" &mdash; общемировой чат;</li>
<li>"trd" &mdash; торговый чат;</li>
<li>"dip" &mdash; дипломатический чат;</li>
<li>"dbg" &mdash; отладочный чат;</li>
<li>"loc-<strong>идентификатор</strong>" &mdash; чат локации с указанным идентификатором (для удобства у объекта Location есть поле channel, которое позволяет узнать идентификатор канала локации).</li>
</ul></p>
<p>Параметр channel не является обязательным. Если он не указан, подразумевается "wld".</p>
<p>Параметр public позволяет сделать сообщение видимым для всех, кто подключен к данному каналу. Если public ложен (или не указан), то считается, что сообщение приватное &mdash; видимое только персонажу, проходящему квест.</p>
<p>К примеру, чтобы сообщение увидели все персонажи из текущей локации, можно написать так:</p>
<pre class="doc-code-sample">
chat text="{char.name} [char.sex:погиб,погибла] в бою" channel=char.location.channel public=1
</pre>

<a name="javascript"></a>
<h2>Исполнение JavaScript</h2>
<pre class="doc-code-sample">
javascript "<strong>скрипт</strong>"
</pre>
<p>Выполняет указанную команду JavaScript в браузере персонажа.</p>

<a name="modifiers"></a>
<h2>Установка модификатора</h2>
<pre class="doc-code-sample">
modifier id="<strong>тип</strong>" add=<strong>секунды</strong> val=<strong>выражение</strong>
modifier id="<strong>тип</strong>" prolong=<strong>секунды</strong> val=<strong>выражение</strong>
modifier id="<strong>тип</strong>" val=<strong>выражение</strong>
</pre>

<p>При помощи этой инструкции можно устанавливать произвольные модификаторы персонажа.</p>
<p>Первая форма инструкции (с add) позволяет создать новый модификатор и задать время его исчезновения через указанное количество секунд. Если на персонаже уже есть модификатор с тем же типом, то он никак не будет взаимодействовать с вновь созданным. Время действия модификатора указывается в атрибуте "add".</p>
<p>Вторая форма инструкции (с prolong) позволяет продлить действие модификатора (если он уже установлен) или установить новый (если его ещё нет). Время продления указывается в атрибуте "prolong".</p>
<p>Если не указать ни add, ни prolong, то модификатор будет установлен навсегда.</p>

<p>Атрибут "val" во всех формах записи инструкции не обязателен. Если его указать, то будет установлен модификатор с указанным значением. Если не указать, то значение будет принято равным 1. Это может быть полезно при получении суммы, максимума и минимума среди установленных модификаторов. Например, если выдавать модификатор силы +5 на полчаса при каждом съедании "чернобыльского яблока":</p>
<pre class="doc-code-sample">
modifier id="u_super_strength" add=1800 val=5
</pre>
<p>То 3 съеденных яблока приведут к тому, что выражение char.mod.sum_u_super_strength будет равно 15.</p>
<p>При использовании prolong все ранее существовавшие модификаторы этого типа полностью удаляются, а на их место ставится один новый модификатор с увеличенным сроком действия и с значением "val".</p>

<p>Выбор идентификатора модификатора остаётся на усмотрение администратора. Рекомендуется начинать собственные идентификаторы с какого-нибудь необычного префикса, чтобы избежать коллизий с идентификаторами платных услуг или других подписок, которые могут появиться в дальнейшем. Обычно пользовательские идентификаторы начинаются с префикса "u_".</p>

<h2>Удаление модификатора</h2>
<pre class="doc-code-sample">
modifier remove id="<strong>тип</strong>"
</pre>

<p>Эта инструкция удаляет все модификаторы персонажа с указанным типом. Может использоваться для досрочного прекращения каких-либо платных услуг или других подписок.</p>

<a name="object"></a>
<h1>Объект квеста</h1>

<p>Через скриптовый движок можно получить доступ к объекту квеста, чтобы получать его состояние и изменять его. Объект каждого квеста существует для каждого персонажа в отдельности. То есть, если изменить параметр в квесте у одного персонажа, то на других персонажей это не повлияет.</p>

<p>Чтобы получить доступ к объекту квеста, напишите:</p>
<pre class="doc-code-sample">
char.q_<strong>идентификатор</strong>
</pre>
<p>Идентификатор &mdash; это идентификатор нужного квеста. Кроме того, когда выполняется квестовый обработчик, существует глобальная переменная "quest", которая ссылается на объект текущего квеста. Например, когда вы пишете обработчик для квеста "courier", следующие условия эквивалентны:</p>
<pre class="doc-code-sample">
require quest.notlocked
require char.q_courier.notlocked
</pre>

<h2>Поля объекта Quest</h2>
<ul>
	<li>p_<strong>параметр</strong> &mdash; любой произвольный параметр, который администратор хочет сохранить для данного квеста (эти параметры можно изменять через set);</li>
	<li>state &mdash; синоним p_state;</li>
	<li>locked &mdash; 1, если квест заблокирован, и 0, если нет;</li>
	<li>notlocked &mdash; 0, если квест заблокирован, и 1, если нет;</li>
	<li>finished &mdash; 1, если квест пройден, и 0, если нет;</li>
	<li>notfinished &mdash; 0, если квест пройден, и 1, если нет.</li>
</ul>
<p>Если вам необходим доступ к другим полям, закажите его через <a href="/doc/reqauction">Аукцион заявок</a>.</p>

<p>Администратор может хранить в объекте квеста любые параметры, которые описывают ход его прохождения. К примеру, в этих параметрах можно запомнить детали выданного задания (если оно выдаётся случайно), количество монстров, которые надо убить, количество растений, которые ещё осталось собрать и т.д.</p>

<h1>Административный интерфейс</h1>

<p>На странице админки с информацией о персонаже есть вкладка "Квесты", через которую администратор может посмотреть ход прохождения квестов данным персонажем: <img class="doc-screenshot" src="/st/tutorial/quests-7.png" alt="" /></p>
<p>Через этот же интерфейс можно сбросить диалоги, показанные игроку.</p>

<h1>Вёрстка диалогов</h1>

<p>Для отображения диалогов используется шаблон <a href="/doc/game-template/dialog.html">dialog.html</a>. Информация о том, как изменять шаблоны, приведена в разделе <a href="/doc/design/gameinterface">Игровой интерфейс</a>. Доступны следующие параметры шаблонизатора:<ul>
	<li>title &mdash; заголовок диалога (может отсутствовать);</li>
	<li>content &mdash; содержание диалога (может отсутствовать);</li>
	<li>buttons &mdash; список кнопок (может отсутствовать). Если присутствует, то это список, каждый элемент которого имеет поля:<ul>
		<li>href &mdash; ссылка, куда надо будет отправить POST-запрос при нажатии на кнопку;</li>
		<li>event &mdash; значение параметра "event", которое надо отправлять при нажатии на кнопку;</li>
		<li>text &mdash; текст, написанный на кнопке.</li>
	</ul></li>
</ul></p>
<p>При нажатии на кнопку на сервер по указанному адресу должен отправляться POST-запрос с параметрами ok=1 и event=событию, которое выбрано игроком.</p>

<h1>Дополнительно</h1>
<ul>
	<li><a href="/doc/script">Описание скриптового движка</a></li>
</ul>
