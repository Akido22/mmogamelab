<!-- doc.title Боевая система в конструкторе онлайн-игр -->
<!-- doc.parent index -->
<!-- doc.keywords боевая система, бои, онлайн-игры -->
<!-- doc.description Описание процесса настройки боевых систем в конструкторе онлайн-игр -->

<h1>Боевая система</h1>

<p>Основное взаимодействие персонажей в онлайн-играх, которое позволяет монетизировать игру, как правило, связано с боями. Бои создают необходимый уровень агрессии в играх, требуют от игроков прикладывать усилия для того, чтобы побеждать. Боевая система &mdash; ядро онлайн-игры. Все остальные модули, как правило, считаются вспомогательными по отношению к боям.</p>

<p>MMO Constructor позволяет иметь в одной игре несколько различных боевых систем. Они никак не связаны друг с другом и могут настраиваться индивидуально. Чтобы получить возможность создания боевых систем в игре, необходимо <a href="/doc/modules">подключить модуль</a> "Боевой движок".</p>

<p>После этого в административном интерфейсе игры появится пункт меню "Бои", через который можно настраивать боевые системы.</p>

<h1>Основные понятия</h1>

<p><strong>Боем</strong> называется непрерывный по времени процесс, в течение которого его <strong>участники</strong> совершают боевые действия, нацеленные друг на друга. В бою могут участвовать 2 или более участников.</p>
<p>Участниками могут быть персонажи (в этом случае ими управляют игроки), виртуальные участники (в этом случае ими управляет искусственный интеллект).</p>
<p><strong>Активным</strong> (живым) называется участник, который может совершать действия. Как только участник становится неактивным (погибает), действия он совершать не может.</p>
<p><strong>Командой</strong> называется группа участников, действующих в общих интересах. Бой продолжается, пока как минимум в двух командах есть хотя бы один активный участник. Если по результатам обсчёта хода остаётся только одна команда, в которой есть активные участники, эта команда считается <strong>победившей</strong>. Все участники, состоявшие в победившей команде, считаются победителями боя, даже если они не были активны на момент окончания боя. Если по результатам обсчёта хода не остаётся ни одного активного участника, бой завершается с <strong>ничейным</strong> результатом.</p>
<p><strong>Боевые действия</strong> &mdash; любые действия, совершаемые участниками боя. Фактический эффект от действий определяется скриптами, написанными на <a href="#scripts">боевом MMO Script</a>.</p>
<p>Скрипты боевой системы не могут взаимодействовать с базой данных игры (не могут получать или изменять параметры персонажей, модификаторы, предметы и т.д.). Бой может повлиять на базу данных только в момент его окончания, когда вызывается специальное квестовое событие, которое может быть обработано скриптами квестового движка.</p>
<p><strong>Право хода</strong> &mdash; параметр участника боя, который определяет, может ли в данный момент участник сделать ход. При некоторых обстоятельствах право хода может быть выдано участнику, при некоторых &mdash; отнято. Возможно, что в один момент времени несколько участников имеют право хода.</p>
<p><strong>Очерёдность ходов</strong> &mdash; алгоритм, запрограммированный в коде конструктора, который определяет порядок выдачи и отнятия права хода. Этот алгоритм выбирается в настройках конкретной боевой системы.</p>

<h1>Базовая настройка боевой системы</h1>

<p>Чтобы настроить боевую систему с чистого листа, администратор игры должен иметь чёткое представление о внутреннем устройстве всех компонентов боевой системы конструктора. Чтобы облегчить эту задачу, создание боевой системы начинается с выбора готового шаблона, который в дальнейшем можно расширять и дорабатывать по желанию администратора.</p>

<p>Чтобы создать новую боевую систему, зайдите в раздел "Бои / Правила боёв" и нажмите на ссылку "Новые правила боёв": <img class="doc-screenshot" src="/st/tutorial/combats-01.png" alt="" /></p>

<p>После того, как шаблон выбран, необходимо настроить его параметры, на основании которых будет сгенерирована боевая система: <img class="doc-screenshot" src="/st/tutorial/combats-02.png" alt="" /></p>

<p>Необходимо указать код правил боёв и их название. Код будет использоваться в квестовом движке, чтобы начать бой, а название видно только администратору в админке. После задания всех параметров система сгенерирует новую боевую систему, которая будет видна в списке правил: <img class="doc-screenshot" src="/st/tutorial/combats-03.png" alt="" /></p>

<p>Когда администратор игры генерирует первую боевую систему, для него, кроме собственно боевой системы, будет автоматически сгенерирован квест "combat_triggers", который определяет типовые квестовые обработчики для боёв:<ul>
    <li>при поражении ломать экипировку с вероятностью 50%;</li>
    <li>при победе начислять опыт;</li>
    <li>при нажатии на пункт "Напасть" во всплывающем меню персонажа начать бой с ним.</li>
</ul></p>

<p>В списке доступных пунктов для выпадающего меню появится новый пункт "Напасть", который можно внести в меню нажатием на ссылку "показать": <img class="doc-screenshot" src="/st/tutorial/combats-04.png" alt="" /></p>

<p>Для того, чтобы персонаж мог получать опыт, а также для того, чтобы учитывать его запас жизни, урон и защиту в бою, необходимы соответствующие параметры. Они также будут сгенерированы автоматически. Их названия необходимо ввести в форме создания боевой системы. Если такие параметры уже существуют, то они замещены не будут. Если они отсутствуют, то будут созданы. Таким образом, после создания боевой системы она сразу готова к работе.</p>

<h1>Настройка основных параметров боевой системы</h1>

<p>Основные параметры боевой системы настраиваются при нажатии на ссылку "профиль боевой системы": <img class="doc-screenshot" src="/st/tutorial/combats-05.png" alt="" /></p>

<ul>
    <li>название &mdash; видно только администратору;</li>
    <li>порядок сортировки &mdash; все боевые системы будут отсортированы в порядке возрастания этого параметра;</li>
    <li>общий таймаут боя (в секундах) &mdash; задаёт ограничение на максимальную продолжительность боя. Если по истечении этого интервала времени бой ещё не будет закончен, он будет принудительно остановлен с ничьей. Если бой не успеет сохраниться ещё в течение 10 минут после этого, то он будет остановлен принудительно;</li>
    <li>очерёдность ходов в бою &mdash; определяет алгоритм, по которому участники будут получать и терять право хода;</li>
    <li>таймаут на ход &mdash; столько секунд будет выдаваться участнику боя, чтобы сделать ход. Если в течение этого времени ход не будет сделан, то будет вызван специальный скриптовый обработчик, который сможет либо убить "заснувшего" участника боя, либо совершать ходы за него автоматически;</li>
    <li>выводить трассировку скрипта в отладочный чат &mdash; позволяет наблюдать за исполнением MMO Script в отладочном канале чата;</li>
    <li>выводить трассировку скрипта в отладочный лог &mdash; позволяет записывать ход исполнения MMO Script прямо в отладочный лог боя;</li>
    <li>режим визуализации времени &mdash; позволяет настроить, как будет отображаться время боя в логе:<ul>
        <li>не показывать время &mdash; название говорит само за себя;</li>
        <li>показывать в начале каждой строки лога &mdash; время будет подставляться в начало каждой строки;</li>
        <li>выводить в лог после каждого изменения &mdash; каждый раз, когда время будет меняться, в лог боя будет выводиться запись об этом;</li>
    </ul></li>
    <li>формат времени &mdash; настраивает вид времени (если точнее, то определяет значение, чему будет равно свойство боя combat.timetext):<ul>
        <li>ММ:СС &mdash; показывает боевые минуты и секунды. Считается, что счётчик времени боя (combat.time) считает секунды с момента начала боя;</li>
        <li>обычное число &mdash; просто показывается текущее значение счётчика combat.time (как обычное целое число);</li>
        <li>реальное время ЧЧ:ММ:СС &mdash; выводит время, не связанное с combat.time. Вместо этого берётся реальное время в часовом поясе игры;</li>
    </ul></li>
    <li>настройки аватаров определяют картинки, которые будут передаваться в клиент вместе с параметрами участников боя:<ul>
        <li>размер аватара &mdash; определяет картинку, которая будет браться из параметров персонажа.
    </ul></li>
</ul>

<h1>Универсальный интерфейс боя</h1>

<p>Конструктор предоставляет администратору игры гибкие возможности по разработке собственного боевого интерфейса. Администратор может использовать любые технологии, допустимые в браузере (JavaScript, HTML5, Flash, Unity, другие плагины), чтобы сделать собственную визуализацию боя. Для этого есть специальный API, который позволяет интегрировать клиентскую часть с сервером игры. Подробно об этом написано в разделе <a href="/doc/combatapi">клиентский API</a>.</p>

<p>Для тех, кто не будет делать собственный клиент, конструктор предоставляет универсальный (generic) интерфейс, который пользуется тем же API. Администратор игры может также использовать за основу универсальный интерфейс, переопределив в нём какие-либо функции под себя. Универсальный интерфейс можно настроить через админку игры, установив в "профиле боевой системы" галочку "Использовать универсальный GUI для этого типа боёв": <img class="doc-screenshot" src="/st/tutorial/combats-06.png" alt="" /></p>

<p>Универсальный интерфейс позволяет включать или отключать отображение аватаров двух персонажей (слева и справа):<ul>
    <li>настройки "аватара слева" определяют параметры картинки участника боя, которым управляет игрок;</li>
    <li>настройки "аватара справа" определяют параметры картинки участника боя, которого игрок видит напротив себя (обычно это враг);</li>
    <li>у каждого из аватаров задаётся ширина &mdash; это количество пикселей, отводимых слева и справа экрана для этих аватаров.</li>
</ul></p>

<p>Отображение лога боя управляется следующими настройками:<ul>
    <li>показать лог боя снизу &mdash; позволяет включать или отключать область экрана, в которой в реальном времени показываются последние события из лога боя;</li>
    <li>размещение лога боя &mdash; позволяет определить размеры лога:<ul>
        <li>сделать высоту лога боя фиксированной (а элементам управления боя отдать всё остальное место на экране);</li>
        <li>наоборот, элементам управления боем отдать фиксированную высоту, а лог боя будет занимать всё остальное место;</li>
    </ul></li>
    <li>позволить игроку растягивать лог боя &mdash; отображает разделительную полоску над логом, которую можно передвигать мышью.</li>
</ul></p>

<p>Кнопка действия:<ul>
    <li>использовать кнопку "Go" &mdash; определяет необходимость показать кнопку, по нажатию на которую ход будет отправляться на сервер. Если эту кнопку отключить, то ход будет отправляться, когда игрок кликнет на действие и отметит все цели, на которые он хочет это действие нацелить. Режим без кнопки "Go" удобен тем, что игроку надо делать меньше кликов мышью. Однако он не позволяет использовать атрибуты действий;</li>
    <li>текст кнопки "Go" &mdash; позволяет заменить стандартный текст кнопки на любой другой.</li>
</ul></p>

<p>Шаблоны имён участников:<ul>
    <li>шаблон имени участника в списке целей действия &mdash; текст со вставками <a href="/doc/script">скриптовых выражений</a>, определяющий, как отображать список участников боя в списке целей для действия. Настройки по умолчанию перечёркивают имя неактивных участников, а активных расцвечивают зелёным (союзников) и красным (противников);</li>
    <li>шаблон имени участника во время ожидания права хода &mdash; когда игрок ждёт своего хода, у него на экране вместо интерфейса выбора действия отображается список участников боя. Настройки по умолчанию расцвечивают участников красным и зелёным, перечёркивают погибших, а также отображают полоски жизни участников.</li>
</ul></p>

<p>Универсальный интерфейс предоставляет возможности для гибкой настройки аватаров участников боя, которые показываются слева и справа. Над каждым (и под каждым) аватаром можно отобразить какие-либо произвольные данные (параметры участников, полоски жизни и любые другие данные): <img class="doc-screenshot" src="/st/tutorial/combats-07.png" alt="" /></p>

<p>Нажав на ссылку "Создать новый элемент" или на "редактировать", откроется редактор элемента: <img class="doc-screenshot" src="/st/tutorial/combats-08.png" alt="" /></p>

<ul>
    <li>Порядок сортировки &mdash; поле, позволяющее упорядочить вывод элементов в интерфейсе. Чем число больше, тем ниже будет элемент;</li>
    <li>условие видимости &mdash; выражение MMOScript, вычисляемое на стороне клиента. Обратите внимание, что интерпретатору в клиенте доступны не все параметры, а только те, которые переаются на клиент. В этом выражении доступны глобальные переменные: combat (бой), member (участник, чьи параметры выводятся), viewer (участник, который просматривает параметры);</li>
    <li>тип элемента &mdash; сейчас доступен единственный тип: "HTML-шаблон с MMOScript", который позволяет сформировать HTML-код элемента. Пример, приведённый на скриншоте, показывает код для полоски жизни участника боя. Формирование этого текста также происходит на клиенте, что накладывает те же ограничения на доступность параметров в скрипте.</li>
</ul>

<h1>Доставка параметров в клиент</h1>

<p>Как было сказано в предыдущем разделе, часть выражений MMO Script вычисляется не на сервере (как обычно), а на клиенте. Чтобы клиент мог использовать какие-либо параметры боя или участнка боя, необходимо их передавать в клиент.</p>

<p>Администратор имеет возможность настроить перечень параметров, которые он будет передавать. При выборе учтите, что чем больше параметров вы будете передавать, тем больше трафика будет потреблять ваша игра. Кроме того, все параметры, что передаются в клиент, уже не могут считаться секретными от игроков. При использовании <a href="/doc/design/firebug">нехитрых программ</a> можно просмотреть все данные, доставляемые в браузер.</p>

<p>Чтобы настроить список параметров, нажмите на ссылку "доставка параметров в клиент" в списке боевых систем: <img class="doc-screenshot" src="/st/tutorial/combats-09.png" alt="" /></p>

<p>Страница состоит из двух частей: параметров боя и парамеров участника боя. При нажатии на ссылку "Доставить новый параметр" или на "редактировать", откроется редактор параметра: <img class="doc-screenshot" src="/st/tutorial/combats-10.png" alt="" /></p>

<ul>
    <li>код параметра &mdash; соответствует коду пользовательского параметра скриптового движка, устанавливаемого через MMO Script. Код должен начинаться с "p_";</li>
    <li>условие видимости &mdash; скриптовое выражение, вычисляемое на сервере, которое определяет, разрешена ли доставка параметра в клиент конкретного участника боя. Например, чтобы какой-то параметр был виден только его владельцу, пропишите условие:
    <pre class="doc-code-sample">member.id == viewer.id</pre>
    Если надо сделать параметр видимым только для союзников, напишите:
    <pre class="doc-code-sample">member.team == viewer.team</pre>
    Если по ходу боя условие видимости станет ложным, то с точки зрения клиента это будет выглядеть, как то, что параметр стал равным null.</li>
</ul>

<p>Кроме настраиваемых пользовательских параметров в клиент также доставляются системные параметры. Для боя это:<ul>
    <li>stage &mdash; текущая стадия боя (обычно это "init" (подготовка к бою), затем combat (ход боя), в конце done (завершение боя));</li>
    <li>title &mdash; название боя;</li>
    <li>time &mdash; значение счётчика времени боя (ходов, тайм-юнитов, и т.п.);</li>
    <li>timetext &mdash; текстовое представление текущего времени (зависит от настроек формата представления времени).</li>
</ul></p>

<p>Для участника боя системные параметры таковы:<ul>
    <li>name &mdash; имя участника боя;</li>
    <li>sex &mdash; его пол (0=мужской, 1=женский);</li>
    <li>team &mdash; номер команды участника;</li>
    <li>may_turn &mdash; есть ли в данный момент право хода;</li>
    <li>active &mdash; активен (жив) ли в данный момент участник (1=активен, 0=нет);</li>
    <li>image &mdash; изображение участника (URL картинки);</li>
    <li>targets &mdash; предварительно выбранные сервером (preselected) цели. Если сервер позволяет совершать действия только в отношении выбранных целей, то он передаёт в этом параметре список идентификаторов участников, которые являются целями. Если игроку позволено выбирать цели самому, то этот параметр равен "selectable". Параметр targets передаётся только владельцу участника боя.</li>
</ul></p>

<h1>Настройка боевых действий</h1>

<p>Ход боя состоит в том, что участники в определённой очерёдности совершают боевые действия. Доступые действия настраиваются в админке, доступной под ссылкой "боевые действия": <img class="doc-screenshot" src="/st/tutorial/combats-11.png" alt="" /></p>

<p>Ссылка "профиль боевого действия" открывает редактор основных параметров действия: <img class="doc-screenshot" src="/st/tutorial/combats-12.png" alt="" /></p>

<ul>
    <li>код действия &mdash; это код, который используется в скриптах для того, чтобы сослаться на это действие;</li>
    <li>порядок сортировки &mdash; определяет порядок, в котором действия будут показываться в боевом интерфейсе;</li>
    <li>название действия &mdash; будет видно игроку в боевом интерфейсе;</li>
    <li>описание действия &mdash; HTML-текст, показываемый при наведении мыши на действие в игровом интерфейсе. Этот текст может содержать скриптовые выражения, вычисляемые на стороне клиента. Это накладывает ограничения на доступные параметры;</li>
    <li>условие доступности &mdash; скриптовое выражение, вычисляемое на сервере. Определяет, может ли участник "member" выполнить это действие. Значение 1 означает, что безусловно может;</li>
    <li>немедленное исполнение &mdash; позволяет выполнить действие, не дожидаясь своей очереди хода. Полезно использовать, например, для платного лечения, чтобы игрок мог вылечиться в любой момент;</li>
    <li>продолжительность в тайм-юнитах &mdash; используется в боевых системах с продолжительными действиями (когда моменты начала и окончания действия разнесены во времени);</li>
    <li>игнорировать предварительно выбранные цели &mdash; если ваша боевая система использует предварительно выбранные (preselected) цели (например, боевая система со спаррингами, когда система составляет пары из участников и предлагает им выбрать действие, которое надо совершить в отношении выбранной пары), то установка этого признака позволяет отключить принудительный выбор цели для конкретного действия. Это может быть полезно, например, для действия "лечение", которое должно быть направлено на себя, а не на выбранного врага.</li>
</ul>

<p>Фильтр доступности целей позволяет ограничить цели, доступные участнику боя:<ul>
    <li>нет &mdash; если целей у действия нет (например, если оно только влияет на сам бой, но не влияет ни на кого из участников);</li>
    <li>все активные участники боя &mdash; можно использовать действие на любого активного (живого) участника;</li>
    <li>все активные враги &mdash; самый популярный вариант, который означает, что действие атакующее и направлено против врагов;</li>
    <li>все активные союзники &mdash; можно использовать на любого союзника, но не на себя;</li>
    <li>все активные союзники и я сам &mdash; можно использовать на любого союзника и на себя;</li>
    <li>только я сам &mdash; заклинание используется на себя;</li>
    <li>скриптовое выражение &mdash; при этом открывается дополнительное поле, в которое можно ввести скрипт, который определит более сложные условия для использования действия. В скрипте доступны глобальные переменные "member" (участник, совершающий действие) и "target" (участник, на которого нацелено действия). Если скрипт возвращает истину, то действие будет разрешено. Если 0, то запрещено.</li>
</ul></p>

<p>Рандомизация доступных целей позволяет случайно выбирать несколько целей из всего множества доступных. Если галочка "все отобранные цели доступны для выбора" установлена, то рандомизация отключается. Если галочку снять, то открываются дополнительные настройки, которые позволяют настроить рандомизацию: <img class="doc-screenshot" src="/st/tutorial/combats-13.png" alt="" /></p>

<ul>
    <li>ограничение числа целей &mdash; это скриптовое выражение, определяющее количество целей, которое надо случайно отобрать из всего множества доступных. Отбор осуществляется следующим образом: сначала система случайно перемешивает все возможные цели, затем выбирает первые N из полученного списка;</li>
    <li>сортировка перед применением лимита &mdash; перед тем как выбирать N первых участников, можно отсортировать список. Если соответствующая галочка установлена, то можно настроить сортировку. Администратор может ввести несколько параметров, по которым надо сортировать участников. При равенстве первых значений, сравниваются вторые. При равенстве первых и вторых, сравниваются третьи и т.д. Если все значения выражений равны у обоих участников, то их порядок в списке будет определяться случайным числом. Использование сортировки позволяет, например, подбирать в качестве целей наиболее близких по уровню противников. Или наиболее медленных, или ещё как-то.</li>
</ul>

<p>Количество возможных целей &mdash; это раздел, позволяющий настроить минимальное и максимальное количество целей, которые выбраны одновременно при совершении этого действия. Оба значения &mdash; это скриптовые выражения, которым доступна глобальная переменная "member", определяющая участника, для которого определяются параметры действия.</p>

<p>После того, как параметры действия настроены, можно открыть вторую ссылку ("атрибуты боевого действия"), которая позволяет настроить атрибуты боевых действий: <img class="doc-screenshot" src="/st/tutorial/combats-14.png" alt="" /></p>

<p>Нажатия на ссылки "Новый атрибут действия" или на "редактировать" откроют редактор атрибута: <img class="doc-screenshot" src="/st/tutorial/combats-15.png" alt="" /></p>

<ul>
    <li>код атрибута &mdash; определяет название параметра, который будет передаваться из клиента на сервер, а также который попадёт в обработчики скриптов;</li>
    <li>порядок сортировки &mdash; определяет порядок отображения атрибутов в интерфейсе боя;</li>
    <li>название атрибута &mdash; показывается в клиенте;</li>
    <li>тип значений атрибута &mdash; имеет следующие варианты:<ul>
        <li>статический список &mdash; при этом варианты выбора для игрока ограничены предлагаемым набором. Каждый вариант указывается с новой строки и состоит из кода (произвольной строки без пробелов), двоеточия и текста, который надо показать игроку;</li>
        <li>целочисленное значение &mdash; позволяет игроку указывать произвольный целочисленный параметр. Предполагается использовать для реализации различных нестандартных боевых систем.</li>
    </ul></li>
</ul>

<p>Скриптовые обработчики действия доступны по ссылке "скриптовые обработчики" и будут более подробно описаны в следующем разделе.</p>

<a name="scripts"></a>
<h1>Боевые скрипты</h1>

<p>По ходу боя происходит большое количество событий, которые можно обработать при помощи скриптов. Боевые скрипты написаны на специальном диалекте MMO Script и позволяют обращаться только к данным, локальным для боя &mdash; это параметры самого боя, параметры участников, а также выполнять различные команды в отношении системы искусственного интеллекта и системы очерёдности ходов. Доступ к внешним по отношению к бою данным (параметры персонажей, база данных и т.д.) закрыт. Это сделано для контроля за нагрузкой, которую боевые скрипты создают на систему.</p>

<p>Порядок возникновения событий определяется очерёдностью ходов, настроенной в разделе "профиль боевой системы". Дальнейшее рассмотрение скриптов неотделимо от ссылок на конкретную очерёдность ходов.</p>

<h1>Действия при выполнении скриптовых обработчиков</h1>

<p>В этом разделе приведён перечень действий, которые можно выполнить при срабатывании обработчика. Все действия в скрипте выполняются последовательно сверху вниз.</p>

<p>В этом разделе используются обозначения:<ul>
    <li><strong>выражение</strong> &mdash; выражение <a href="/doc/script">скриптового движка</a>;</li>
    <li><strong>текстовое выражение</strong> &mdash; текстовая строка, которая может <a href="/doc/script#text">формироваться</a> скриптовым движком.</li>
</ul></p>

<p>Во всех скриптовых обработчиках доступна глобальная переменная "combat", ссылающаяся на текущий бой, и "local", представляющая собой объект <a href="/doc/script#local">ScriptMemoryObject</a>, позволяющий сохранять временные значения.</p>

<h2>Изменение параметра</h2>
<pre class="doc-code-sample">
set <strong>объект</strong>.<strong>параметр</strong> = <strong>выражение</strong>
</pre>
<p>Эта команда позволяет изменять параметры у объектов, которые это позволяют. К примеру, чтобы увеличить счётчик нанесённого участником боя урона:</p>
<pre class="doc-code-sample">
set source.p_inflicted_damage = source.p_inflicted_damage + 10
</pre>
<p>Аналогичным образом можно изменять состояние боя:</p>
<pre class="doc-code-sample">
set combat.p_stage = "done"
</pre>

<h2>Вычисление агрегирующих функций участников</h2>
<pre class="doc-code-sample">
set <strong>объект</strong>.<strong>параметр</strong> = select &lt;min|max|count|distinct|sum|mult&gt;(<strong>выражение</strong>) from members [where <strong>условие</strong>]
</pre>
<p>Эта команда позволяет вычислять значения функций min, max и т.д. над произвольными выражениями, использующими параметры участников, и сохранять их в параметрах объектов. Доступны следующие функции:<ul>
    <li>min &mdash; минимальное значение из всего списка. Если значения отсутствуют, возвращается null;</li>
    <li>max &mdash; максимальное значение из всего списка. Если значения отсутствуют, возвращается null;</li>
    <li>count &mdash; количество объектов. Если значения отсутствуют, возвращается 0;</li>
    <li>distinct &mdash; количество различных значений. Если значения отсутствуют, возвращается 0;</li>
    <li>sum &mdash; сумма значений. Если значения отсутствуют, возвращается 0;</li>
    <li>mult &mdash; произведение значений. Если значения отсутствуют, возвращается 1.</li>
</ul></p>

<p>При вычислении выражения доступна глобальная переменная "member", определяющая текущего участника, для которого вычисляется выражение. Если задано условие where, то к рассмотрению принимаются только участники, удовлетворяющие этому условию.</p>

<p>Примеры использования:<ul>
    <li>найти самое большое значение хитпоинтов среди участников боя:
    <pre class="doc-code-sample">
    set local.p_max_hp = select max(member.p_hp) from members
    </pre>
    </li>
    <li>найти среднее значение хитпоинтов среди живых участников боя:
    <pre class="doc-code-sample">
    set local.p_sum_hp = select sum(member.p_hp) from members where member.active
    set local.p_cnt = select count(1) from members where member.active
    set local.p_avg_hp = local.p_sum_hp / (local.p_cnt or 1)
    </pre>
    </li>
</ul></p>

<h2>Нанесение урона</h2>
<pre class="doc-code-sample">
damage <strong>участник</strong>.<strong>параметр</strong> value <strong>урон</strong> [maxval=<strong>макс</strong>]
</pre>
<p>Эта команда уменьшает значение указанного параметра участника на значение выражения "урон". Но так, чтобы результирующее выражение не стало меньше нуля. Необязательный атрибут "maxval" указывает системе, какое максимальное значение у этого параметра может быть. Maxval используется только для вывода текста в лог боя. Например:</p>
<pre class="doc-code-sample">
damage member.p_hp value 15 maxval=20
</pre>
<p>Помимо уменьшения параметра, эта команда установит глобальные переменные:<ul>
    <li>last_damage &mdash; количество фактически нанесённого урона (может быть меньше запрошенного, если значение упёрлось в ноль);</li>
    <li>action_log &mdash; HTML-строка, которая пригодна для занесения в лог боя. К примеру, для указанного выше примера, она может быть: "-15 [3/20]". В строку, кроме текста, добавляется HTML-разметка, позволяющая стилизовать отображение.</li>
</ul></p>
<p>Если на момент вызова damage глобальная переменная action_log уже существовала, то она будет дополнена (не заменена) новым значением. Это позволяет наносить урон несколько раз, а вывести всё в лог одной строкой.</p>

<h2>Лечение</h2>
<pre class="doc-code-sample">
heal <strong>участник</strong>.<strong>параметр</strong> value <strong>выражение</strong> [maxval=<strong>макс</strong>]
</pre>
<p>Команда, аналогичная нанесению урона, за исключением того, что она не уменьшает значение параметра, а увеличивает. Значение не может вырасти больше, чем maxval (если он указан).</p>
<p>Аналогично команде damage, heal выставляет глобальные переменные:<ul>
    <li>last_heal &mdash; количество фактически вылеченных хитпоинтов;</li>
    <li>action_log &mdash; HTML-строка вида "+15 [20/20]".</li>
</ul></p>

<h2>Выбор цели для участника</h2>
<pre class="doc-code-sample">
selecttarget <strong>участник</strong> where <strong>выражение</strong>
</pre>
<p>Эта команда перебирает список всех участников боя, для каждого из них вычисляет значение выражения. Выражению доступны глобальные переменные:<ul>
    <li>member &mdash; участник, для которого выбирается цель;</li>
    <li>target &mdash; участник, для которого проверяется возможность быть целью.</li>
</ul></p>
<p>Если выражение возвращает истину, то этот участник считается возможной целью. Затем из всех участников выбирается один случайный и записывается в атрибут участника "targets".</p>
<p>Если не удалось выбрать цель, то в targets запишется null.</p>

<h2>Условный оператор</h2>
<pre class="doc-code-sample">
if <strong>условие</strong> {
  ...
}
</pre>
<p>Условие &mdash; это скриптовое выражение. Если оно истинно, то блок "..." выполняется. Если ложно, то пропускается.</p>
<pre class="doc-code-sample">
if <strong>условие</strong> {
  ...
} else {
  ...
}
</pre>
<p>В этой форме оператора если условие истинно, то выполняется первый блок. Если ложно, то второй.</p>

<h2>Вывод сообщений в лог боя</h2>
<pre class="doc-code-sample">
log <strong>текст</strong> [атрибут=<strong>выражение</strong>, ...]
syslog <strong>текст</strong> [атрибут=<strong>выражение</strong>, ...]
</pre>
<p>Эти команды выводят в лог боя записи, которые затем будут доступны в пользовательском логе (команда log) или в отладочном логе (команда syslog).</p>
<p>Каждая запись в логе боя представляет собой JSON-объект с полями произвольного назначения. Эти записи затем передаются в шаблонизатор для отображения, а также доставляются в клиент (только пользовательские логи).</p>
<p>Текст, переданный первым параметром, записывается в тот же JSON-объект как поле "text". Стандартный шаблон лога боя проверяет также поле "cls", в которое можно записать CSS-класс, которым надо оформить строку в логе. Например:</p>
<pre class="doc-code-sample">
log '{class="combat-log-member"}{member.name}{/class} {class="combat-log-dead"}[member.sex:потерял сознание и погиб,потеряла сознание и погибла]{/class}' cls="dead"
</pre>

<h2>Вывод сообщения в чат</h2>
<pre class="doc-code-sample">
chat "<strong>текст</strong>" channel=<strong>выражение</strong> cls=<strong>выражение</strong>
</pre>
<p>Выводит указанный текст в чат персонажа. Текст &mdash; это текстовое выражение. В нём разрешено использование тегов HTML, т.е. можно в чат выводить хоть картинки, хоть видеоролики с youtube. Это обязательный параметр.</p>
<p>Параметр channel определяет канал, в который следует отправить сообщение. Допустимыми значениями являются:<ul>
<li>"sys" &mdash; системный чат (без возможности фильтрации, доставляется всем);</li>
<li>"wld" &mdash; общемировой чат;</li>
<li>"trd" &mdash; торговый чат;</li>
<li>"dip" &mdash; дипломатический чат;</li>
<li>"dbg" &mdash; отладочный чат;</li>
<li>"loc-<strong>идентификатор</strong>" &mdash; чат локации с указанным идентификатором (для удобства у объекта Location есть поле channel, которое позволяет узнать идентификатор канала локации).</li>
</ul></p>
<p>Параметр channel не является обязательным. Если он не указан, подразумевается "wld".</p>
<p>Параметр cls позволяет задать CSS-класс для сообщения. Строка будет склеена с префиксом "chat-msg-". Например, если вывести:</p>
<pre class="doc-code-sample">
chat "Авария на 4 энергоблоке ЧАЭС" cls="major-alert"
</pre>
то в чат попадёт блок:
<pre class="doc-code-sample">
&lt;div class="chat-msg-major-alert"&gt;Авария на 4 энергоблоке ЧАЭС&lt;/div&gt;
</pre>

<h2>Постановка действия в очередь</h2>
<pre class="doc-code-sample">
action <strong>участник</strong> <strong>действие</strong> [атрибут=<strong>выражение</strong>, ...]
</pre>
<p>Эта команда ставит в очередь действий участника действие, код которого задаётся вторым аргументом. Дополнительно можно задать любые атрибуты действия, если указать их в конце команды. Обратите внимание, что указанная команда не проводит никаких проверок на допустимость данного действия для данного участника боя, а также никак не валидирует переданные аргументы (которые могут даже не быть описаны в свойствах действия). Все аргументы будут переданы как есть в скриптовый обработчик действия.</p>
<p>При постановке действия в очередь оно будет нацелено на те цели, которые в данный момент записаны в атрибуте "targets" участника.</p>
<p>Пример использования:</p>
<pre class="doc-code-sample">
selecttarget member where target.active and member.team != target.team
action member "strike" a_attack_zone=2 a_defend_zone=3
</pre>
<p>Здесь сначала выбирается живой противник (и записывается в member.targets), а затем в него направляется удар ("strike") с указанными атрибутами.</p>

<h2>Выбор случайного действия</h2>
<pre class="doc-code-sample">
randomaction <strong>участник</strong> <strong>"набор действий"</strong> [атрибут=<strong>выражение</strong>, ...]
</pre>
<p>В отличие от предыдущей команды, эта выполняет проверки доступности действия и его целей перед постановкой действия в очередь. Сначала эта команда перебирает все действия, указанные администратором игры в параметре "набор действий". Набор действий задаётся в формате: "действие: вес, действие: вес, ...". Действие &mdash; это код действия, вес &mdash; это число, задающее распределение вероятности выбора того или иного действия.</p>
<p>Пример использования:</p>
<pre class="doc-code-sample">
randomaction member "long_strike: 2, short_strike: 2, heal: 1"
</pre>
<p>В данном примере суммарный вес равен 5, это значит, что вероятность выбора действия long_strike равна 2/5=40%, short_strike &mdash; 40%, heal &mdash; 20%.</p>
<p>При задании набора действий допустимо использовать скриптовые вставки. Например, можно сделать монстра, который чем ближе к смерти, тем чаще использует страшное заклинание wind_of_death:</p>
<pre class="doc-code-sample">
randomaction member "long_strike: 2, short_strike: 2, heal: 1, wind_of_death: {20 / (member.p_hp + 5)}"
</pre>
<p>После того, как система переберёт все запрошенные администратором заклинания и случайно выберет то, которое будет использовать, она начинает выбирать доступные для действия цели. Если не нашлось достаточно целей, чтобы удовлетворить условиям минимального и максимального количества целей, то это действие исключается из рассмотрения, и процесс выбора нового действия повторяется. Если доступных действий не нашлось совсем, то никакое действие в очередь не ставится. Это может привести к тому, что участник боя пропустит ход по таймауту.</p>

<h2>Отправка произвольной команды системе определения очерёдности ходов</h2>
<pre class="doc-code-sample">
turn <strong>"код"</strong> [атрибут=<strong>выражение</strong>, ...]
</pre>
<p>У каждой системы определения очерёдности ходов этот набор команд может быть своим. Подробности использования читайте в описании конкретной системы.</p>

<h2>Выдача права хода</h2>
<pre class="doc-code-sample">
giveturn <strong>участник</strong>
</pre>
<p>Выдаёт право хода участнику боя, минуя систему определения очерёдности. Может быть полезно, чтобы при таймауте участника боя он не пропускал ход совсем, а получал какое-то случайное заклинание в очередь. Чтобы этого достичь, надо в обработчике таймаута участника боя прописать:</p>
<pre class="doc-code-sample">
giveturn member
randomaction member "weak_strike: 1"
</pre>
<p>Тогда при таймауте система сначала отберёт у участника право хода, затем вызовет указанный обработчик, где участнику будет возвращено право хода, и тут же за него этот ход будет сделан.</p>

<a name="sounds"></a>
<h2>Воспроизведение звука</h2>
<pre class="doc-code-sample">
sound <strong>URL</strong> [mode=<strong>режим</strong>] [volume=<strong>громкость</strong>] [target=<strong>участник</strong>]
</pre>
<p>Воспроизводит звуковой файл, доступный по указанному URL.</p>
<p>Параметр mode определяет режим воспроизведения звука:<ul>
<li>stop &mdash; все текущие звуки отключаются, и воспроизводится указанный звук;</li>
<li>overlap &mdash; новый звук наложится на уже воспроизводимые (этот режим используется по умолчанию);</li>
<li>wait &mdash; система подождёт, пока закончат воспроизводиться все звуки, и потом воспроизведёт данный.</li>
</ul></p>
<p>Параметр volume определяет громкость звука в процентах. По умолчанию &mdash; 50.</p>
<p>Если параметр target не задан, то звук будет воспроизведён для всех участников боя. Если задан, то в нём должна быть ссылка на участника боя, которому воспроизвести звук.</p>

<h2>Воспроизведение музыки</h2>
<pre class="doc-code-sample">
music <strong>"плейлист"</strong> [fade=<strong>миллисекунды</strong>] [volume=<strong>громкость</strong>] [target=<strong>участник</strong>]
</pre>
<p>Переключает текущий воспроизводимый плейлист на указанный идентификатор.</p>
<p>Параметр fade отвечает за плавную смену одного трека другим. В нём задаётся количество миллисекунд, в течение которых старый трек будет затухать, а новый становиться громче. Если указать fade=0, то трек заменится резко. По умолчанию &mdash; 3000.</p>
<p>Параметр volume определяет громкость музыки в процентах. По умолчанию &mdash; 50.</p>
<p>Если параметр target не задан, то музыка будет включена для всех участников боя. Если задан, то в нём должна быть ссылка на участника боя, которому включить музыку.</p>

<h2>Остановка музыки</h2>
<pre class="doc-code-sample">
music stop [fade=<strong>миллисекунды</strong>] [target=<strong>участник</strong>]
</pre>
<p>Отключает воспроизводимую музыку.</p>
<p>Параметр fade отвечает за плавность отключения музыки. В нём задаётся количество миллисекунд, в течение которых старый трек будет затухать. Если указать fade=0, то музыка остановится резко. По умолчанию &mdash; 3000.</p>
<p>Если параметр target не задан, то музыка будет отключена для всех участников боя. Если задан, то в нём должна быть ссылка на участника боя, которому отключить музыку.</p>

<h1>Боевые события, на которые можно ставить обработчики</h1>

<p>Администратор игры может настроить скриптовые обработчики для различных боевых событий. Часть из них настраивается в редакторе скриптов всей боевой системы (открывается по ссылке "скриптовые обработчики" в списке боевых систем), часть &mdash; в свойствах боевых действий (открывается по ссылке "скриптовые обработчики" в списке действий).</p>

<h2>События боевой системы</h2>

<p>Всем обработчикам событий доступны глобальные переменные:<ul>
    <li>combat &mdash; текущий бой.</li>
</ul></p>

<p>Доступные обработчики:</p>

<ul>
    <li>Боевой скрипт, выполняемый, когда бой начинается &mdash; выполняется, когда к бою присоединились все участники и выставлена стадия боя "combat".</li>
    <li>Боевой скрипт, выполняемый, когда присоединяется участник "member" &mdash; выполняется столько раз, сколько участников присоединяется к бою. Может вызываться как до события "бой начался" (если участники присоединились в самом начале), так и после (если участники вмешиваются в бой уже после его начала).</li>
    <li>Боевой скрипт, выполняемый для участника "member" сразу после того, как он получает право хода &mdash; когда участнику предоставляется право хода, сначала выставляется атрибут may_turn=true, затем вызывается этот обработчик.</li>
    <li>Боевой скрипт, выполняемый для участника "member" сразу после того, как он теряет право хода &mdash; когда у участника забирают право хода (как правило, после того, как он сходил), сначала выставляется атрибут may_turn=false, а затем вызывается этот обработчик. Если право хода потеряно по таймауту, то этот обработчик не вызывается.</li>
    <li>Боевой скрипт, выполняемый для участника "member" сразу после того, как он делает ход &mdash; как только участник делает свой очередной ход, действие сначала ставится в очередь. После того, как оно поставлен в очередь, вызывается этот обработчик. Если действие выполняется немедленно, минуя очередь (см. признак "Немедленное исполнение"), то событие не вызывается.</li>
    <li>Боевой скрипт, выполняемый для участника "member" сразу после того, как произошёл таймаут ожидания его хода &mdash; если участник не сделал ход в течение отведённого ему времени, фиксируется таймаут. При этом сначала у участника выставляется атрибут may_turn=false, а затем вызывается этот обработчик. Как указано выше в разделе про скрипты, команда giveturn позволяет вернуть право хода участнику прямо из обработчика таймаута.</li>
    <li>Боевой скрипт, выполняемый на каждой итерации главного цикла (heartbeat-скрипт) &mdash; вычисляется на каждой итерации главного цикла боя. Не стоит нагружать его без особой необходимости тяжёлыми вычислениями.</li>
    <li>Heartbeat-скрипт, выполняемый для каждого участника "member" &mdash; то же самое, что и предыдущий обработчик, но вызывается для каждого участника боя. При этом доступна глобальная переменная "member". Причём сначала выполняются heartbeat-обработчики для участников, а в конце &mdash; глобальный обработчик для всего боя.</li>
    <li>Боевой скрипт, выполняемый после того, как бой был не занят каждую целую 1 секунду (idle-скрипт) &mdash; если в течение секунды бой не выполнял никаких действий и не принимал никаких команд от участников боя, бой считается простаивающим (idle), и вызывается этот обработчик.</li>
    <li>Idle-скрипт, выполняемый для каждого участника "member" &mdash; то же самое, что и предыдущий скрипт, но выполняющийся для каждого участника боя ("member"). Причём сначала выполняются idle-обработчики для участников, а в конце &mdash; глобальный обработчик для всего боя.</li>
    <li>Боевой скрипт, выполняемый после того, как начали выполняться какие-то действия &mdash; если на текущей итерации цикла начали выполняться какие-то действия, то после начала всех действий будет вызван этот обработчик.</li>
    <li>Боевой скрипт, выполняемый для участника "member" после того, как начали выполняться какие-то действия &mdash; то же самое, что и предыдущий скрипт, но выполняющийся для каждого участника "member". Причём сначала выполняются обработчики для участников, а в конце &mdash; глобальный обработчик для всего боя.</li>
    <li>Боевой скрипт, выполняемый после того, как закончили выполняться какие-то действия &mdash; если на текущей итерации цикла закончили выполняться какие-то действия, то после окончания всех действий будет вызван этот обработчик.</li>
    <li>Боевой скрипт, выполняемый для участника "member" после того, как закончили выполняться какие-то действия &mdash; то же самое, что и предыдущий скрипт, но выполняющийся для каждого участника "member". Обычно используется для того, чтобы проверить, не погибли ли какие-то участники боя после того, как на них выполнились действия. Причём сначала выполняются обработчики для участников, а в конце &mdash; глобальный обработчик для всего боя.</li>
    <li>Боевой скрипт, выполняемый, когда бой закончился ничьей &mdash; если в бою зафиксирована ничья, то вызывается этот обработчик. Чтобы бой завершился, необходимо в этом обработчике выставить флаг combat.stage = "done"</li>
    <li>Боевой скрипт, выполняемый для каждого участника "member", когда бой закончился ничьей &mdash; то же самое, что и предыдущий скрипт, но выполняющийся для каждого участника "member". Причём сначала выполняются обработчики для участников, а в конце &mdash; глобальный обработчик для всего боя.</li>
    <li>Боевой скрипт, выполняемый, когда бой закончился победой команды "winner_team" &mdash; если бой закончился победой одной из команд, то вызывается этот обработчик. Ему передаются глобальные переменные:<ul>
        <li>winner_team &mdash; идентификатор победившей команды;</li>
        <li>winners_list &mdash; текстовый список, перечисляющий победивших участников боя;</li>
        <li>loosers_list &mdash; текстовый список, перечисляющий проигравших участников боя;</li>
        <li>first_winner &mdash; первый из победителей (полезно использовать для правильного склонения текста в логе боя, если участник один "победил/победила/победили");</li>
        <li>first_looser &mdash; первый из проигравших;</li>
        <li>winners_count &mdash; количество победителей;</li>
        <li>loosers_count &mdash; количество проигравших.</li>
    </ul></li>
    <li>Боевой скрипт, выполняемый на каждого проигравшего участника &mdash; вызывается для каждого из членов команд, проигравших бой (не вызывается при ничьей).</li>
    <li>Боевой скрипт, выполняемый на каждого участника-победителя &mdash; вызывается для каждого из членов победившей команды (даже для погибших). Порядок выполнения обработчиков при победе таков: сначала вызываются все обработчики поражения для участников, затем все обработчики победы для участников, затем глобальный обработчик победы для всего боя.</li>
</ul>

<h2>События действий</h2>

<p>Всем обработчикам событий, привязанных к действию, доступны глобальные переменные:<ul>
    <li>combat &mdash; текущий бой;</li>
    <li>source &mdash; участник, выполняющий действие;</li>
    <li>targets &mdash; список целей, на которых направлено действие;</li>
    <li>все атрибуты действия (начинаются с префикса "a_") доступны как глобальные переменные.</li>
</ul></p>

<p>Доступные обработчики:</p>

<ul>
    <li>Действие поставлено в очередь &mdash; вызывается сразу после того, как действие получено боевой системой от участника боя и перед тем, как оно будет либо исполнено сразу (при установленном признаке "Немедленное исполнение"), либо поставлено в очередь.</li>
    <li>Начало исполнения &mdash; вызывается, когда действие начинает исполняться.</li>
    <li>Начало исполнения на цель "target" &mdash; вызывается, когда действие начинает исполняться, по разу на каждую из целей ("target") действия. Причём сначала выполняется обработчик для каждой из целей, а в конце &mdash; глобальный обработчик для всего действия.</li>
    <li>Конец исполнения &mdash; вызывается, когда действие закончило выполняться.</li>
    <li>Конец исполнения на цель "target" &mdash; вызывается, когда действие закончило выполняться, по разу на каждую из целей ("target") действия. Причём сначала выполняется обработчик дл
    я каждой из целей, а в конце &mdash; глобальный обработчик для всего действия.</li>
</ul>

<a name="object"></a>
<h1>Скриптовые объекты</h1>

<h2>Объект Combat</h2>
<p>Этот объект предоставляет доступ к текущему бою.</p>
<ul>
    <li>id &mdash; идентификатор боя;</li>
    <li>stage &mdash; текущая стадия боя ("init", "combat", "done");</li>
    <li>stage_flags &mdash; объект "флаги стадии", через который можно уточнить информацию о наличии флага текущей стадии боя:<ul>
        <li>actions &mdash; можно ли на текущей стадии совершать действия;</li>
        <li>done &mdash; является ли текущая стадия завершающей бой;</li>
    <li>time &mdash; счетчик текущего боевого времени;</li>
    <li>timetext &mdash; представление времени боя в текстовом формате, настроенном администратором;</li>
    <li>now &mdash; текущее реальное время в временной зоне игры в формате ГГГГ-ММ-ДД ЧЧ:ММ:СС;</li>
    <li>team<strong>N</strong>_list &mdash; HTML-список участников команды N;</li>
    <li>p_* &mdash; любые пользовательские атрибуты боя (их можно читать и писать без предварительного объявления).</li>
</ul>

<h2>Объект CombatMember</h2>
<p>Этот объект предоставляет доступ к участнику текущему бою.</p>
<ul>
    <li>id &mdash; идентификатор участника боя;</li>
    <li>name &mdash; имя участника боя;</li>
    <li>sex &mdash; пол участника боя (0=мужской, 1=женский);</li>
    <li>may_turn &mdash; имеет ли в данный момент право хода;</li>
    <li>active &mdash; является ли активным (живым);</li>
    <li>targets &mdash; список фиксированных целей либо строка "selectable";</li>
    <li>p_* &mdash; любые пользовательские атрибуты участника (их можно читать и писать без предварительного объявления).</li>
</ul>

<h2>Объект CombatAction</h2>
<p>Этот объект предоставляет доступ к действию в текущем бою.</p>
<ul>
    <li>a_* &mdash; любые пользовательские атрибуты действия.</li>
</ul>

<h1>Очерёдность выполнения ходов</h1>

<p>В зависимости от настроек боевой системы, выбирается один из алгоритмов определения очерёдности ходов. Каждый из них определяет порядок, в котором участникам предоставляется и отнимается право хода, а также порядок выполнения действий участников.</p>

<h2>Круговая система</h2>

<p>Это самая простая система, которая предоставляет участникам право хода строго по очереди. Одновременно право хода есть только у одного участника. Когда участник делает ход:<ol>
    <li>у него отбирается право хода;</li>
    <li>действие немедленно выполняется полностью (начинается и сразу заканчивается);</li>
    <li>право хода либо возвращается тому же участнику, либо передаётся следующему.</li>
</ol></p>

<p>Если один из обработчиков начала или конца действия выполнил команду <strong>turn "done"</strong>, то диспетчер считает, что ход участника завершён, и передаёт право хода следующему. Иначе возвращает тому же участнику.</p>

<p>Такая система позволяет организовать более сложные системы, позволяющие делать несколько действий за один ход. Например, типовую систему с "очками действия", в которой за ход участник может сделать несколько действий, но так, чтобы суммарные очки действий были не больше допустимых.</p>

<h2>Парный обмен</h2>

<p>Это режим, в котором система предлагает каждому участнику выбрать действие против каждого из противников. Как только выбраные взаимные встречные действия для двух участников, они немедленно исполняются. Порядок, в котором участнику предлагаются противники, случаен.</p>

<p>После того, как подобрана пара действий, каждому из них устанавливается атрибут "a_pair", указывающие друг на друга. Это позволяет в обработчике действия проверять, какое действие сделал другой участник боя. Например:</p>
<pre class="doc-code-sample">
if a_pair and a_pair.a_defend_zone &amp; a_attack_zone {
  ... удар попал в блок ...
} else {
  ... удар попал мимо блока ...
}
</pre>
<p>Если парного действия не существует (например, если второй участник не совершил никакого действия по таймауту), то a_pair будет равен none, что и проверяется в начале приведённого примера.</p>

<h2>Таймлайн</h2>

<p>В бою существует единая лента времени (таймлайн). В момент времени 0 (начало боя) все участники сразу получают право хода. Как только все сделают ход, все выбранные ими действия начинают выполняться (вызываются обработчики "начало выполнения действия"). Каждое действие имеет длительность выполнения (указывается в параметрах действия). Далее счётчик времени увеличивается на 1 каждую секунду. Как только наступает время, когда заканчивается какое-либо действие, для него вызывается обработчик "окончание выполнения действия", а этому участнику предоставляется право выбрать следующее действие.</p>

<h1>Алгоритмы искусственного интеллекта</h1>

<p>По ссылке "алгоритмы искусственного интеллекта" в списке боевых систем открывается список алгоритмов: <img class="doc-screenshot" src="/st/tutorial/combats-16.png" alt="" /></p>

<p>Нажав на ссылку "Новый тип ИИ" или на "профиль типа ИИ" откроется редактор общих параметров алгоритма: <img class="doc-screenshot" src="/st/tutorial/combats-17.png" alt="" /></p>

<ul>
    <li>код &mdash; определяет код, при помощи которого можно выбрать данный алгоритм для участника боя;</li>
    <li>порядок сортировки &mdash; определяет порядок, в котором алгоритмы выводятся в административном интерфейсе;</li>
    <li>название &mdash; показывается только в админке.</li>
</ul>

<p>По ссылке "скриптовые обработчики" можно задать собственно алгоритм, по которому ИИ будет выбирать действия: <img class="doc-screenshot" src="/st/tutorial/combats-18.png" alt="" /></p>

<p>Этот скрипт должен выполнить либо команду "action" (тогда не будут проверяться условия доступности действия), либо команду "randomaction", чтобы выбрать действие и цели для него автоматически.</p>

<h1>Действия в начале боя</h1>

<p>Когда бой начинается, выполняются следующие действия:<ol>
    <li>к нему присоединяются все участники;</li>
    <li>участники-персонажи получают начальные значения всех параметров, в точности переписанных с параметров персонажа;</li>
    <li>состояние боя переводится в "combat";</li>
    <li>вызывается боевой обработчик начала боя;</li>
    <li>для каждого из участников-персонажей вызывается <a href="/doc/quests#combats">квестовое событие "начало боя"</a>;</li>
    <li>участники боя, которым положено совершить первый ход, получают право хода.</li>
</ol></p>

<p>Квестовый обработчик &mdash; это программа на квестовом диалекте MMO Script, который получает в качестве параметра ссылки на объекты "combat", "member" и "char" одновременно, что позволяет переписать из базы данных игры в параметры боя какие-то дополнительные параметры (например, подключенные платные услуги или действующие модификаторы). Дальше в течение боя доступа к параметрам персонажа не будет.</p>

<h1>Действия при завершении боя</h1>

<p>Когда бой заканчивается победой одной из команд, выполняются следующие обработчики:<ol>
    <li>для всех проигравших персонажей вызывается <a href="/doc/quests#combats">квестовое событие "поражение в бою"</a>;</li>
    <li>для всех победивших персонажей вызывается <a href="/doc/quests#combats">квестовое событие "победа в бою"</a>;</li>
    <li>для всех проигравших участников боя вызывается боевое событие "поражение";</li>
    <li>для всех победивших участников боя вызывается боевое событие "победа";</li>
    <li>вызывается общее боевое событие "победа".</li>
</ol></p>

<p>Когда бой заканчивается ничьей, выполняются следующие обработчики:<ol>
    <li>для всех персонажей вызывается <a href="/doc/quests#combats">квестовое событие "ничья в бою"</a>;</li>
    <li>для всех участников боя вызывается боевое событие "ничья";</li>
    <li>вызывается общее боевое событие "ничья".</li>
</ol></p>

<h1>Сохранение логов боёв</h1>

<p>Логи боёв сохраняются в базе данных игры. Они доступны для просмотра в течение ограниченного времени, через которое они удаляются. Администратор может самостоятельно настраивать время, в течение которого хранятся логи боёв его игры, в интерфейсе "Бои / Конфигурация истории боёв": <img class="doc-screenshot" src="/st/tutorial/combats-20.png" alt="" /></p>

<p>Здесь отдельно настраивается интервал в днях, после которого логи (отдельно пользовательские, отдельно системные) можно удалять.</p>

<p>Кроме ограничений, заданных администратором, есть и лимит объёма логов, установленный отдельно для каждой игры, в зависимости от её доходности. Текущие лимиты вместе со статистикой по месту, занимаемому логами, можно посмотреть в интерфейсе "Бои / Посмотреть статистику по боям": <img class="doc-screenshot" src="/st/tutorial/combats-21.png" alt="" /></p>

<p>Если объём логов превышает предельно допустимый для этой игры, то логи будут удаляться раньше, чем истекает интервал, заданный администратором.</p>

<h1>Дополнительно</h1>
<ul>
    <li><a href="/doc/script">Описание скриптового движка</a></li>
    <li><a href="/doc/quests">Описание квестового движка</a></li>
    <li><a href="/doc/design/combatinterface">Оформление боевого интерфейса</a></li>
    <li><a href="/doc/combatapi">Клиентский API боевого интерфейса</a></li>
</ul>
